# ES6学习笔记

--------------------------------------------------------------------------------

## let和const命令

`let`和`const`是es6新增的用来声明变量的语法关键字。类似于`var`，但所声明的变量只在其所在的代码块内有效。

- 不存在变量提升， 或者说是变量提升了，但是js解析器禁止在`let`声明前使用变量。因此会出现**暂时性死区**（从代码块开始到`let`声明处的区域）。因此，在暂时性死区内的`typeof`不在是一个百分之百安全安全的操作。

  ```javascript
  {
  typeof x;   // ReferenceError
  let x;
  }
  ```

- 不允许重复声明，`let`声明的变量绑定其所在代码块，在代码块内重复声明一个已经声明过的变量会报错，因此也不能在函数内重新声明参数。除非以下形式。

  let不允许在相同作用域内，重复声明同一个变量。

  ```javascript
  //报错
  function() {
     let a = 10;
     var a = 1;
  }

  //报错
  function() {
     let a = 10;
     let a = 2;
  }
  ```

  因此，不能在函数内重新声明参数。

  ```javascript
  function(arg) {
     let arg ; //报错
  }

  function(arg) {
     {
         let arg; //不报错
     }
  }
  ```

--------------------------------------------------------------------------------

## 变量的解构赋值

ES6允许按照一定`模式`,从数组和对象中提取值，对变量进行赋值。

--------------------------------------------------------------------------------

### 1.数组的解构赋值

- 完全解构

  ```javascript
  let [a, b, c] = [1, 2, 3]
  // a === 1
  // b === 2
  // c === 3

  let [foo, [[bar], baz]] = [1, [[2], 3]]
  // foo === 1
  // bar === 2
  // baz === 3

  let [, , third] = [1,2,3];
  // third ==== 3

  let [x, , y] = ["a", "b", "c"]
  // x === "a"
  // y === "c"

  let = [head, ...nail] = [1, 2, 3, 4, 5]
  // head === 1
  // nail === [2, 3, 4, 5]

  let [foo] = []
  let [baz, foo] = [1]
  //以上两种情况都属于解构不成功，foo的值都会等于`undefined`
  ```

- 不完全解构

  即等号左边的模式只匹配一部分等号右边的数组。这种情况下，解构依然可以成功。

  ```javascript
  let [x, y] = [1, 2, [10]]
  // x === 1
  // y === 2

  let [a, [b], c] = [1, [2, 3], 4]
  // a === 1
  // b === 2
  // c === 4
  ```

  如果等号右边的不是数组将会报错。

--------------------------------------------------------------------------------

- 默认值

  解构赋值允许指定默认值

  ```javascript
  var [foo = true] = [];
  // foo === true
  ```

  ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格相等于`undefined`，默认值是不生效的。

  ```javascript
  var [foo = 1] = [];
  // foo === 1

  var [foo = 1] = [null];
  // foo === null
  ```

  如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。

  ```javascript
  function f() {
    return "hello"
  }
  var [foo = f()] = [1]
  // foo === 1
  ```

  这段代码等价于下面的代码

  ```javascript
  function f() {
    return "hello"
  }

  let foo;
  if( [1][0] === undefined) {
    foo = f();
  } else {
    foo = [1][0]
  }
  ```

--------------------------------------------------------------------------------

### 2.对象的解构赋值

对象的解构跟数组有一个重要的不同。数组的元素的按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，因此变量必须与属性同名才能取到正确的值。

```javascript
var {bar , foo} = {foo:"aaa", bar: "bbb"}
// bar === "bbb"
// foo === "aaa"
```

如果变量名与属性名不一致的情况下必须写成这样：

```javascript
var {foo: bar} = {foo: "aaa"}
//bar === "aaa"

var {first: f, last: l} = {first: "hello", last: "world"}
// f === "hello"
// l === "world"
```

这实际上说明，对象的解构赋值是下面形式的简写。

```javascript
var {foo: foo, bar: bar} = {foo: "aaa", bar: "bbb"}
```

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```javascript
var {foo: bar} = {foo: "123", bar = "456"}
// bar === "123"
// error: foo is not defined
```

上面代码中，真正被赋值的是变量 `bar` ，而不是模式 `foo`。

- 对象的解构同样可以指定默认值。

- 默认值生效的条件是，对象的属性严格相等于 `undefined`。

- 如果要将一个已经声明的变量用于解构赋值，必须非常小心。

  ```javascript
  //错误的写法
    var x;
    {x} = {x:1};
    //SyntaxError: syntax error
  ```

  上面的代码会报错，因为JavaScript引擎会将`{x}`理解为一个代码块，从而发生语法错误。**只有不将大括号写在行首**，避免JavaScript引擎将其解释为代码块，才能解决这个问题。

  ```javascript
    //正确的写法
    var x;
    ({x} = {x: 1});
  ```

***

### 3.字符串的解构赋值

- 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。

 ```javascript
    const [a,b,c,d,e] = "hello";
    // a === "h"
    // b === "e"
    // c === "l"
    // d === "l"
    // e === "o"
 ```

- 类似数组的对象都有一个length属性，因此还可以对这个属性进行解构。

 ```javascript
    let {length: len} = "hello"
    // len === 5;
 ```

****
